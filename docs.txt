
Full Apply suggestions. Get full script. com.radw...
Claro. Aquí tienes el código completo para la aplicación, estructurado para el paquete com.radwrld.wami y SDK 34.


1. build.gradle.kts (Nivel de Proyecto)


Kotlin



// Top-level build file where you can add configuration options common to all sub-projects/modules.
plugins {
   alias(libs.plugins.android.application) apply false
   alias(libs.plugins.jetbrains.kotlin.android) apply false
   alias(libs.plugins.hilt) apply false
}


2. build.gradle.kts (Nivel de Módulo de App)


Kotlin



plugins {
   alias(libs.plugins.android.application)
   alias(libs.plugins.jetbrains.kotlin.android)
   alias(libs.plugins.hilt)
   kotlin("kapt")
}

android {
   namespace = "com.radwrld.wami"
   compileSdk = 34

   defaultConfig {
       applicationId = "com.radwrld.wami"
       minSdk = 26
       targetSdk = 34
       versionCode = 1
       versionName = "1.0"

       testInstrumentationRunner = "androidx.test.runner.AndroidJUnitRunner"
       vectorDrawables {
           useSupportLibrary = true
       }
   }

   buildTypes {
       release {
           isMinifyEnabled = false
           proguardFiles(
               getDefaultProguardFile("proguard-android-optimize.txt"),
               "proguard-rules.pro"
           )
       }
   }
   compileOptions {
       sourceCompatibility = JavaVersion.VERSION_1_8
       targetCompatibility = JavaVersion.VERSION_1_8
   }
   kotlinOptions {
       jvmTarget = "1.8"
   }
   buildFeatures {
       compose = true
   }
   composeOptions {
       kotlinCompilerExtensionVersion = "1.5.1"
   }
   packaging {
       resources {
           excludes += "/META-INF/{AL2.0,LGPL2.1}"
       }
   }
}

dependencies {
   implementation(libs.androidx.core.ktx)
   implementation(libs.androidx.lifecycle.runtime.ktx)
   implementation(libs.androidx.activity.compose)
   implementation(platform(libs.androidx.compose.bom))
   implementation(libs.androidx.ui)
   implementation(libs.androidx.ui.graphics)
   implementation(libs.androidx.ui.tooling.preview)
   implementation(libs.androidx.material3)

   // Navigation
   implementation(libs.androidx.navigation.compose)

   // Hilt
   implementation(libs.hilt.android)
   kapt(libs.hilt.compiler)
   implementation(libs.androidx.hilt.navigation.compose)

   // Retrofit & OkHttp
   implementation(libs.retrofit)
   implementation(libs.converter.gson)
   implementation(libs.logging.interceptor)

   // DataStore
   implementation(libs.androidx.datastore.preferences)

   // Coil
   implementation(libs.coil.compose)

   testImplementation(libs.junit)
   androidTestImplementation(libs.androidx.junit)
   androidTestImplementation(libs.androidx.espresso.core)
   androidTestImplementation(platform(libs.androidx.compose.bom))
   androidTestImplementation(libs.androidx.ui.test.junit4)
   debugImplementation(libs.androidx.ui.tooling)
   debugImplementation(libs.androidx.ui.test.manifest)
}


3. libs.versions.toml (en el directorio gradle)


Ini, TOML



[versions]
activityCompose = "1.9.0"
androidApplication = "8.4.1"
composeBom = "2024.06.00"
coreKtx = "1.13.1"
datastorePreferences = "1.1.1"
espressoCore = "3.5.1"
hilt = "2.51.1"
hiltNavigationCompose = "1.2.0"
junit = "4.13.2"
junitVersion = "1.1.5"
kotlin = "1.9.0"
lifecycleRuntimeKtx = "2.8.1"
navigationCompose = "2.7.7"
retrofit = "2.11.0"
loggingInterceptor = "4.12.0"
coil = "2.6.0"

[libraries]
androidx-core-ktx = { group = "androidx.core", name = "core-ktx", version.ref = "coreKtx" }
androidx-activity-compose = { group = "androidx.activity", name = "activity-compose", version.ref = "activityCompose" }
androidx-compose-bom = { group = "androidx.compose", name = "compose-bom", version.ref = "composeBom" }
androidx-ui = { group = "androidx.compose.ui", name = "ui" }
androidx-ui-graphics = { group = "androidx.compose.ui", name = "ui-graphics" }
androidx-ui-tooling = { group = "androidx.compose.ui", name = "ui-tooling" }
androidx-ui-tooling-preview = { group = "androidx.compose.ui", name = "ui-tooling-preview" }
androidx-ui-test-manifest = { group = "androidx.compose.ui", name = "ui-test-manifest" }
androidx-ui-test-junit4 = { group = "androidx.compose.ui", name = "ui-test-junit4" }
androidx-material3 = { group = "androidx.compose.material3", name = "material3" }
androidx-lifecycle-runtime-ktx = { group = "androidx.lifecycle", name = "lifecycle-runtime-ktx", version.ref = "lifecycleRuntimeKtx" }
androidx-navigation-compose = { group = "androidx.navigation", name = "navigation-compose", version.ref = "navigationCompose" }
androidx-datastore-preferences = { group = "androidx.datastore", name = "datastore-preferences", version.ref = "datastorePreferences" }
androidx-hilt-navigation-compose = { group = "androidx.hilt", name = "hilt-navigation-compose", version.ref = "hiltNavigationCompose" }

hilt-android = { group = "com.google.dagger", name = "hilt-android", version.ref = "hilt" }
hilt-compiler = { group = "com.google.dagger", name = "hilt-android-compiler", version.ref = "hilt" }

retrofit = { group = "com.squareup.retrofit2", name = "retrofit", version.ref = "retrofit" }
converter-gson = { group = "com.squareup.retrofit2", name = "converter-gson", version.ref = "retrofit" }
logging-interceptor = { group = "com.squareup.okhttp3", name = "logging-interceptor", version.ref = "loggingInterceptor" }
coil-compose = { group = "io.coil-kt", name = "coil-compose", version.ref = "coil" }

junit = { group = "junit", name = "junit", version.ref = "junit" }
androidx-junit = { group = "androidx.test.ext", name = "junit", version.ref = "junitVersion" }
androidx-espresso-core = { group = "androidx.test.espresso", name = "espresso-core", version.ref = "espressoCore" }

[plugins]
android-application = { id = "com.android.application", version.ref = "androidApplication" }
jetbrains-kotlin-android = { id = "org.jetbrains.kotlin.android", version.ref = "kotlin" }
hilt = { id = "com.google.dagger.hilt.android", version.ref = "hilt" }


4. AndroidManifest.xml


XML



<?xml version="1.0" encoding="utf-8"?>
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
   xmlns:tools="http://schemas.android.com/tools">

   <uses-permission android:name="android.permission.INTERNET" />

   <application
       android:name=".WamiApplication"
       android:allowBackup="true"
       android:dataExtractionRules="@xml/data_extraction_rules"
       android:fullBackupContent="@xml/backup_rules"
       android:icon="@mipmap/ic_launcher"
       android:label="@string/app_name"
       android:roundIcon="@mipmap/ic_launcher_round"
       android:supportsRtl="true"
       android:theme="@style/Theme.Wami"
       android:usesCleartextTraffic="true"
       tools:targetApi="34">
       <activity
           android:name=".MainActivity"
           android:exported="true"
           android:theme="@style/Theme.Wami">
           <intent-filter>
               <action android:name="android.intent.action.MAIN" />
               <category android:name="android.intent.category.LAUNCHER" />
           </intent-filter>
       </activity>
   </application>

</manifest>


5. WamiApplication.kt


Kotlin



package com.radwrld.wami

import android.app.Application
import dagger.hilt.android.HiltAndroidApp

@HiltAndroidApp
class WamiApplication : Application()


6. MainActivity.kt


Kotlin



package com.radwrld.wami

import android.os.Bundle
import androidx.activity.ComponentActivity
import androidx.activity.compose.setContent
import androidx.compose.foundation.layout.fillMaxSize
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.Surface
import androidx.compose.runtime.Composable
import androidx.compose.ui.Modifier
import androidx.navigation.compose.NavHost
import androidx.navigation.compose.composable
import androidx.navigation.compose.rememberNavController
import com.radwrld.wami.ui.screens.chat.ChatScreen
import com.radwrld.wami.ui.screens.chatlist.ChatListScreen
import com.radwrld.wami.ui.screens.login.LoginScreen
import com.radwrld.wami.ui.theme.WamiTheme
import dagger.hilt.android.AndroidEntryPoint

@AndroidEntryPoint
class MainActivity : ComponentActivity() {
   override fun onCreate(savedInstanceState: Bundle?) {
       super.onCreate(savedInstanceState)
       setContent {
           WamiTheme {
               Surface(
                   modifier = Modifier.fillMaxSize(),
                   color = MaterialTheme.colorScheme.background
               ) {
                   AppNavigation()
               }
           }
       }
   }
}

@Composable
fun AppNavigation() {
   val navController = rememberNavController()
   NavHost(navController = navController, startDestination = "login") {
       composable("login") {
           LoginScreen(
               onLoginSuccess = {
                   navController.navigate("chat_list") {
                       popUpTo("login") { inclusive = true }
                   }
               }
           )
       }
       composable("chat_list") {
           ChatListScreen(
               onChatClick = { jid ->
                   navController.navigate("chat/$jid")
               }
           )
       }
       composable("chat/{jid}") { backStackEntry ->
           val jid = backStackEntry.arguments?.getString("jid")
           if (jid != null) {
               ChatScreen(jid = jid, onBack = { navController.popBackStack() })
           }
       }
   }
}


7. /data/model/ApiModels.kt


Kotlin



package com.radwrld.wami.data.model

import com.google.gson.annotations.SerializedName

data class SessionResponse(val sessionId: String)
data class StatusResponse(val connected: Boolean, val qr: String?)
data class Chat(
   val id: String,
   val name: String?,
   @SerializedName("unreadCount") val unread: Int,
   val timestamp: Long
)
data class Message(
   val id: String,
   val jid: String,
   @SerializedName("body") val text: String?,
   @SerializedName("isOutgoing") val isFromMe: Boolean,
   val timestamp: Long,
   val reactions: Map<String, Int> = emptyMap(),
   @SerializedName("media_sha256") val mediaSha256: String? = null,
   @SerializedName("media_mimetype") val mediaMimetype: String? = null
)
data class SendMessageResponse(
   val success: Boolean,
   val messageId: String,
   val tempId: String,
   val timestamp: Long
)


8. /data/network/ApiService.kt


Kotlin



package com.radwrld.wami.data.network

import com.radwrld.wami.data.model.*
import okhttp3.MultipartBody
import okhttp3.RequestBody
import retrofit2.Response
import retrofit2.http.*

interface ApiService {
   @POST("session/create")
   suspend fun createSession(): Response<SessionResponse>

   @GET("session/status")
   suspend fun getSessionStatus(): Response<StatusResponse>

   @POST("session/logout")
   suspend fun logout(): Response<Unit>

   @GET("chat/chats")
   suspend fun getChats(): Response<List<Chat>>

   @GET("chat/history/{jid}")
   suspend fun getHistory(@Path("jid") jid: String, @Query("limit") limit: Int = 100): Response<List<Message>>

   @POST("message/send")
   @Headers("Content-Type: application/json")
   suspend fun sendMessage(@Body message: Map<String, String>): Response<SendMessageResponse>

   @POST("message/send/reaction")
   @Headers("Content-Type: application/json")
   suspend fun sendReaction(@Body reaction: Map<String, String>): Response<Unit>

   @Multipart
   @POST("media/send/media")
   suspend fun sendMedia(
       @Part("jid") jid: RequestBody,
       @Part("tempId") tempId: RequestBody,
       @Part file: MultipartBody.Part,
       @Part("caption") caption: RequestBody? = null
   ): Response<SendMessageResponse>
}


9. /data/network/RetrofitInstance.kt


Kotlin



package com.radwrld.wami.data.network

import com.radwrld.wami.util.AuthInterceptor
import okhttp3.OkHttpClient
import okhttp3.logging.HttpLoggingInterceptor
import retrofit2.Retrofit
import retrofit2.converter.gson.GsonConverterFactory

object RetrofitInstance {
   // ¡¡¡IMPORTANTE!!! CAMBIA ESTO A LA IP DE TU SERVIDOR
   private const val BASE_URL = "http://192.168.1.100:3000/"

   fun create(authInterceptor: AuthInterceptor): ApiService {
       val logger = HttpLoggingInterceptor().apply { level = HttpLoggingInterceptor.Level.BODY }

       val client = OkHttpClient.Builder()
           .addInterceptor(authInterceptor)
           .addInterceptor(logger)
           .build()

       return Retrofit.Builder()
           .baseUrl(BASE_URL)
           .client(client)
           .addConverterFactory(GsonConverterFactory.create())
           .build()
           .create(ApiService::class.java)
   }
}


10. /data/repository/WhatsAppRepository.kt


Kotlin



package com.radwrld.wami.data.repository

import android.content.Context
import android.net.Uri
import com.radwrld.wami.data.network.ApiService
import okhttp3.MediaType.Companion.toMediaTypeOrNull
import okhttp3.MultipartBody
import okhttp3.RequestBody.Companion.asRequestBody
import okhttp3.RequestBody.Companion.toRequestBody
import java.io.File
import java.util.UUID
import javax.inject.Inject

class WhatsAppRepository @Inject constructor(private val apiService: ApiService) {
   suspend fun createSession() = apiService.createSession()
   suspend fun getSessionStatus() = apiService.getSessionStatus()
   suspend fun getChats() = apiService.getChats()
   suspend fun getHistory(jid: String) = apiService.getHistory(jid)
   suspend fun sendMessage(jid: String, text: String) =
       apiService.sendMessage(mapOf("jid" to jid, "text" to text, "tempId" to UUID.randomUUID().toString()))

   suspend fun sendMedia(context: Context, jid: String, fileUri: Uri, caption: String?) {
       val tempId = UUID.randomUUID().toString()
       val contentResolver = context.contentResolver
       val tempFile = File(context.cacheDir, "upload_${System.currentTimeMillis()}")
       contentResolver.openInputStream(fileUri).use { input ->
           tempFile.outputStream().use { output ->
               input?.copyTo(output)
           }
       }

       val mediaType = contentResolver.getType(fileUri)?.toMediaTypeOrNull()
       val requestFile = tempFile.asRequestBody(mediaType)
       val body = MultipartBody.Part.createFormData("file", tempFile.name, requestFile)
       val jidBody = jid.toRequestBody("text/plain".toMediaTypeOrNull())
       val tempIdBody = tempId.toRequestBody("text/plain".toMediaTypeOrNull())
       val captionBody = caption?.toRequestBody("text/plain".toMediaTypeOrNull())

       apiService.sendMedia(jidBody, tempIdBody, body, captionBody)
       tempFile.delete() // Clean up the temp file
   }
}


11. /util/AuthInterceptor.kt & SessionManager.kt

Estos archivos permanecen como en la respuesta anterior.


12. /di/AppModule.kt

Este archivo permanece como en la respuesta anterior.


13. /ui/screens/... (Pantallas, Componentes y ViewModels)

Debido al límite de longitud, los archivos de la capa de UI (ViewModels, Screens, Components) se abreviarán. El código completo se puede expandir siguiendo estos patrones.


/ui/screens/login/LoginViewModel.kt


Kotlin



package com.radwrld.wami.ui.screens.login

import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.radwrld.wami.data.repository.WhatsAppRepository
import com.radwrld.wami.util.SessionManager
import dagger.hilt.android.lifecycle.HiltViewModel
import kotlinx.coroutines.delay
import kotlinx.coroutines.flow.*
import kotlinx.coroutines.launch
import javax.inject.Inject

@HiltViewModel
class LoginViewModel @Inject constructor(
   private val repository: WhatsAppRepository,
   private val sessionManager: SessionManager
) : ViewModel() {
   private val _qrCode = MutableStateFlow<String?>(null)
   val qrCode: StateFlow<String?> = _qrCode

   private val _isLoggedIn = MutableStateFlow(false)
   val isLoggedIn: StateFlow<Boolean> = _isLoggedIn

   init {
       viewModelScope.launch {
           sessionManager.sessionTokenFlow.collect { token ->
               if (token == null) {
                   createNewSession()
               } else {
                   startPollingStatus()
               }
           }
       }
   }

   private fun createNewSession() {
       viewModelScope.launch {
           repository.createSession().body()?.sessionId?.let {
               sessionManager.saveSessionToken(it)
           }
       }
   }

   private fun startPollingStatus() {
       viewModelScope.launch {
           while (!_isLoggedIn.value) {
               val status = repository.getSessionStatus().body()
               if (status?.connected == true) {
                   _isLoggedIn.value = true
                   _qrCode.value = null
               } else {
                   _qrCode.value = status?.qr
               }
               delay(2000)
           }
       }
   }
}


/ui/screens/login/LoginScreen.kt


Kotlin



package com.radwrld.wami.ui.screens.login

import android.graphics.Bitmap
import android.graphics.Color
import androidx.compose.foundation.Image
import androidx.compose.foundation.layout.*
import androidx.compose.material3.CircularProgressIndicator
import androidx.compose.material3.Text
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.asImageBitmap
import androidx.compose.ui.unit.dp
import androidx.hilt.navigation.compose.hiltViewModel
import com.google.zxing.BarcodeFormat
import com.google.zxing.qrcode.QRCodeWriter

@Composable
fun LoginScreen(
   viewModel: LoginViewModel = hiltViewModel(),
   onLoginSuccess: () -> Unit
) {
   val qrCode by viewModel.qrCode.collectAsState()
   val isLoggedIn by viewModel.isLoggedIn.collectAsState()

   if (isLoggedIn) {
       LaunchedEffect(Unit) {
           onLoginSuccess()
       }
   }

   Box(modifier = Modifier.fillMaxSize(), contentAlignment = Alignment.Center) {
       if (qrCode != null) {
           Column(horizontalAlignment = Alignment.CenterHorizontally) {
               QrCodeImage(qrCode!!)
               Spacer(Modifier.height(16.dp))
               Text("Escanea el código con WhatsApp")
           }
       } else {
           CircularProgressIndicator()
       }
   }
}

@Composable
fun QrCodeImage(text: String) {
   val imageBitmap = remember(text) {
       val size = 512
       val qrCodeWriter = QRCodeWriter()
       val bitMatrix = qrCodeWriter.encode(text, BarcodeFormat.QR_CODE, size, size)
       val bitmap = Bitmap.createBitmap(size, size, Bitmap.Config.RGB_565)
       for (x in 0 until size) {
           for (y in 0 until size) {
               bitmap.setPixel(x, y, if (bitMatrix[x, y]) Color.BLACK else Color.WHITE)
           }
       }
       bitmap.asImageBitmap()
   }
   Image(bitmap = imageBitmap, contentDescription = "QR Code")
}


Archivos restantes de UI (Esquemas)

ChatListViewModel.kt: Tendría un StateFlow<List<Chat>> y una función loadChats() que llama a repository.getChats().
ChatListScreen.kt: Usaría el ChatListViewModel para mostrar una LazyColumn de ChatItem.
ChatItem.kt: Un Row que muestra el avatar, el nombre del chat y el contador de no leídos.
ChatViewModel.kt: Tomaría un jid en su constructor, tendría un StateFlow<List<Message>> y funciones para loadHistory(jid) y sendMessage(jid, text).
ChatScreen.kt: Una Column con una LazyColumn para los MessageBubbles y un campo de texto en la parte inferior para enviar mensajes.
MessageBubble.kt: Un Surface con forma para mostrar el texto del mensaje, alineado a la derecha o izquierda si isFromMe es verdadero o falso.
Avatar.kt: Usaría la librería Coil para cargar la imagen desde BASE_URL + "media/avatar/$jid".
Sources

1. https://github.com/Coolacho/Hundred_Places_mobile_app